name: CI/CD

on:
  # Runs on PRs to master and on pushes (merge) to master
  pull_request:
    branches: [ "master" ]
  push:
    branches: [ "master" ]
  workflow_dispatch:

# Minimal permissions + permission to publish packages to GHCR
permissions:
  contents: read
  packages: write

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  tests:
    name: Tests
    runs-on: ubuntu-latest
    steps:
      # Checkout code
      - name: Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # better for versioning (tags/commits)

      # Set up Java 21 (Temurin) for tests
      - name: Set up Java 21 (Temurin)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'

      # Set up Gradle cache automatically
      - name: Setup Gradle (with caching)
        uses: gradle/actions/setup-gradle@v3

      # Ensure wrapper has execute permission
      - name: Make Gradle wrapper executable
        run: chmod +x gradlew

      # Run test suite
      - name: Run unit tests
        run: ./gradlew --no-daemon clean test

      # Upload test reports always, even on failure
      - name: Upload test reports (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-reports
          path: |
            build/test-results/test
            build/reports/tests/test

  build_and_publish:
    name: Build, Docker and Push
    runs-on: ubuntu-latest
    needs: tests # Only runs if tests pass
    if: ${{ needs.tests.result == 'success' }}
    env:
      # Base image name (adjust as needed)
      APP_NAME: espacogeek-backend


    steps:
      # Checkout code (with full history for versioning)
      - name: Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Normalize owner/repo to lowercase (GHCR requirement)
      - name: Normalize GHCR owner/repo
        shell: bash
        run: |
          OWNER_LC="${GITHUB_REPOSITORY_OWNER,,}"
          REPO_LC="${GITHUB_REPOSITORY#*/}"
          REPO_LC="${REPO_LC,,}"
          echo "GHCR_OWNER_LC=${OWNER_LC}" >> "$GITHUB_ENV"
          echo "GHCR_REPO_LC=${REPO_LC}" >> "$GITHUB_ENV"

      # Set up Java 21 (Temurin) for WAR build
      - name: Set up Java 21 (Temurin)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'

      # Set up Gradle cache for builds
      - name: Setup Gradle (with caching)
        uses: gradle/actions/setup-gradle@v3

      # Ensure wrapper has execute permission (Linux runners)
      - name: Make Gradle wrapper executable
        run: chmod +x gradlew

      # Read the project version defined in build.gradle (project.version)
      - name: Read Gradle project version
        id: gradle_version
        shell: bash
        run: |
          echo "version=$(./gradlew -q properties | sed -n 's/^version: \(.*\)$/\1/p')" >> "$GITHUB_OUTPUT"

      # Generate version tags for Docker images and artifacts
      # - On PR: pr-<number>-<short-sha>, v<version>-pr-<number>
      # - On push to master: latest, sha-<short-sha>, <yyyyMMdd>, v<version>
      - name: Compute version tags
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          SHORT_SHA="$(git rev-parse --short HEAD)"
          DATE_TAG="$(date +%Y%m%d)"
          VERSION="${{ steps.gradle_version.outputs.version }}"
          if [[ "${GITHUB_EVENT_NAME}" == "pull_request" ]]; then
            PR_NUMBER="${{ github.event.pull_request.number }}"
            TAGS="pr-${PR_NUMBER}-${SHORT_SHA},v${VERSION}-pr-${PR_NUMBER}"
            SHOULD_PUSH="false" # do not push on PRs by default
          else
            # push to master
            # Includes the 'last-release' tag (Docker does not allow spaces in tags)
            TAGS="latest,last-release,sha-${SHORT_SHA},${DATE_TAG},v${VERSION}"
            SHOULD_PUSH="true"
          fi
          echo "short_sha=${SHORT_SHA}" >> "$GITHUB_OUTPUT"
          echo "date_tag=${DATE_TAG}" >> "$GITHUB_OUTPUT"
          echo "tags_csv=${TAGS}" >> "$GITHUB_OUTPUT"
          echo "should_push=${SHOULD_PUSH}" >> "$GITHUB_OUTPUT"

      # Set up Docker Buildx and layer cache
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Log in to GHCR (uses GITHUB_TOKEN)
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Normalize the computed tags to a multiline format for docker/buildx
      - name: Prepare tag list (multiline)
        id: tags
        shell: bash
        run: |
          IFS=',' read -ra T <<< "${{ steps.vars.outputs.tags_csv }}"
          printf "jvm_tags<<EOF\n" >> "$GITHUB_OUTPUT"
          for tag in "${T[@]}"; do
            # Use APP_NAME as the JVM image name
            echo "ghcr.io/${{ env.GHCR_OWNER_LC }}/${{ env.APP_NAME }}:$tag" >> "$GITHUB_OUTPUT"
          done
          printf "EOF\n" >> "$GITHUB_OUTPUT"

          printf "native_tags<<EOF\n" >> "$GITHUB_OUTPUT"
          for tag in "${T[@]}"; do
            # Use '-native' suffix to differentiate native image (adjust if needed)
            echo "ghcr.io/${{ env.GHCR_OWNER_LC }}/${{ env.APP_NAME }}-native:$tag" >> "$GITHUB_OUTPUT"
          done
          printf "EOF\n" >> "$GITHUB_OUTPUT"

      # Build Docker image for the JVM app using the existing Dockerfile
      - name: Build JVM Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile.jvm
          platforms: linux/amd64
          push: ${{ steps.vars.outputs.should_push == 'true' && github.event_name == 'push' }}
          tags: ${{ steps.tags.outputs.jvm_tags }}
          labels: |
            org.opencontainers.image.version=${{ steps.gradle_version.outputs.version }}
            org.opencontainers.image.revision=${{ steps.vars.outputs.short_sha }}
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Build Docker image for the app as a Native Image (uses existing Dockerfile)
      - name: Build Native Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile.native
          platforms: linux/amd64
          push: ${{ steps.vars.outputs.should_push == 'true' && github.event_name == 'push' }}
          tags: ${{ steps.tags.outputs.native_tags }}
          labels: |
            org.opencontainers.image.version=${{ steps.gradle_version.outputs.version }}
            org.opencontainers.image.revision=${{ steps.vars.outputs.short_sha }}
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Deploy to Hostinger via SSH (expects secrets: HOSTINGER (private key), HOSTINGER_HOST, HOSTINGER_USER, optional HOSTINGER_PORT)
      - name: Deploy to Hostinger via SSH
        uses: appleboy/ssh-action@v0.1.9
        if: ${{ needs.tests.result == 'success' && steps.vars.outputs.should_push == 'true' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch') }}
        with:
          host: ${{ secrets.HOSTINGER_HOST }}
          username: ${{ secrets.HOSTINGER_USER }}
          key: ${{ secrets.HOSTINGER }}
          port: ${{ secrets.HOSTINGER_PORT }}
          envs: GHCR_OWNER_LC,APP_NAME
          script_stop: false
          script: |
            # Download and setup deploy script if not present
            DEPLOY_SCRIPT="/opt/espacogeek/deploy.sh"

            if [ ! -f "$DEPLOY_SCRIPT" ]; then
              echo "Downloading deploy script..."
              mkdir -p "$(dirname "$DEPLOY_SCRIPT")"
              # You can download from a specific release or use inline
              cat > "$DEPLOY_SCRIPT" << 'DEPLOY_SCRIPT_EOF'
            #!/bin/bash

            set -euo pipefail

            RED='\033[0;31m'
            GREEN='\033[0;32m'
            YELLOW='\033[1;33m'
            BLUE='\033[0;34m'
            NC='\033[0m'

            log_info() { echo -e "${BLUE}[INFO]${NC} $*"; }
            log_success() { echo -e "${GREEN}[✓]${NC} $*"; }
            log_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
            log_error() { echo -e "${RED}[✗]${NC} $*"; }

            trap 'on_error' ERR
            on_error() {
              local exit_code=$?
              if [ $exit_code -ne 0 ]; then
                log_error "Deployment failed with exit code $exit_code"
                log_warn "Attempting rollback..."
                rollback_deployment
              fi
            }

            GHCR_OWNER_LC="${1:-}"
            APP_NAME="${2:-}"
            IMAGE_TAG="${3:-latest}"
            ENV_FILE="${4:-.env.espacogeek}"
            CONTAINER_NAME="espacogeek"
            BACKUP_DIR="${HOME}/espacogeek-backups"
            OLD_CONTAINER_BACKUP="${CONTAINER_NAME}-old"
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)

            if [ -z "$GHCR_OWNER_LC" ] || [ -z "$APP_NAME" ]; then
              log_error "Usage: $0 <GHCR_OWNER_LC> <APP_NAME> [IMAGE_TAG] [ENV_FILE]"
              exit 1
            fi

            IMAGE="ghcr.io/${GHCR_OWNER_LC}/${APP_NAME}:${IMAGE_TAG}"

            container_exists() { docker ps -a --format '{{.Names}}' | grep -q "^${1}$"; }
            container_running() { docker ps --format '{{.Names}}' | grep -q "^${1}$"; }

            backup_old_container() {
              if ! container_exists "$CONTAINER_NAME"; then
                log_info "No existing container to backup"
                return 0
              fi
              log_info "Creating backup of old container..."
              mkdir -p "$BACKUP_DIR"
              BACKUP_FILE="${BACKUP_DIR}/${CONTAINER_NAME}_backup_${TIMESTAMP}.tar"
              log_info "Exporting container to ${BACKUP_FILE}..."
              if docker export "$CONTAINER_NAME" > "$BACKUP_FILE"; then
                log_success "Container backup created: ${BACKUP_FILE}"
              else
                log_error "Failed to backup container"
                return 1
              fi
              ls -t "${BACKUP_DIR}/${CONTAINER_NAME}_backup_"*.tar 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null || true
            }

            rename_old_container() {
              if ! container_exists "$CONTAINER_NAME"; then
                log_info "No old container to rename"
                return 0
              fi
              log_info "Renaming old container..."
              if container_running "$CONTAINER_NAME"; then
                log_info "Stopping old container..."
                docker stop "$CONTAINER_NAME" || log_warn "Failed to stop container"
              fi
              if docker rename "$CONTAINER_NAME" "${OLD_CONTAINER_BACKUP}" 2>/dev/null; then
                log_success "Old container renamed to ${OLD_CONTAINER_BACKUP}"
              else
                log_warn "Could not rename old container"
              fi
            }

            pull_new_image() {
              log_info "Pulling new image: ${IMAGE}..."
              if docker pull "$IMAGE"; then
                log_success "Image pulled successfully"
                return 0
              else
                log_error "Failed to pull image"
                return 1
              fi
            }

            start_new_container() {
              log_info "Starting new container..."
              if ! docker run -d --name "$CONTAINER_NAME" -p 8080:8080 --restart unless-stopped --env-file "$ENV_FILE" "$IMAGE"; then
                log_error "Failed to start container"
                return 1
              fi
              log_success "Container started with ID: $(docker ps --filter name=$CONTAINER_NAME -q)"
            }

            validate_container_health() {
              local max_attempts=40
              local attempt=1
              local initial_wait=5
              log_info "Validating container health (max ${max_attempts} attempts, initial wait ${initial_wait}s)..."

              # Wait for app to start
              log_info "Giving application time to start (${initial_wait}s)..."
              sleep $initial_wait

              while [ $attempt -le $max_attempts ]; do
                if container_running "$CONTAINER_NAME"; then
                  local status=$(docker inspect "$CONTAINER_NAME" --format='{{.State.Status}}')
                  if [ "$status" = "running" ]; then
                    # Try to hit health endpoint
                    local health_response=$(docker exec "$CONTAINER_NAME" curl -s -w "\n%{http_code}" http://localhost:8080/actuator/health 2>&1)
                    local http_code=$(echo "$health_response" | tail -n 1)
                    local body=$(echo "$health_response" | head -n -1)

                    if [ "$http_code" = "200" ]; then
                      log_success "Container is healthy (HTTP $http_code)"
                      log_info "Health response: $body"
                      return 0
                    else
                      log_info "Health endpoint returned HTTP $http_code (attempt ${attempt}/${max_attempts})"
                    fi
                  elif [ "$status" = "exited" ]; then
                    log_error "Container exited (attempt ${attempt}/${max_attempts})"
                    log_error "Recent logs:"
                    docker logs --tail 30 "$CONTAINER_NAME" 2>&1 | sed 's/^/  /'
                    return 1
                  else
                    log_warn "Container status is: $status (attempt ${attempt}/${max_attempts})"
                  fi
                else
                  log_warn "Container not found (attempt ${attempt}/${max_attempts})"
                fi

                sleep 2
                attempt=$((attempt + 1))
              done

              log_error "Container failed health check after ${max_attempts} attempts"
              log_error "Final container logs:"
              docker logs --tail 50 "$CONTAINER_NAME" 2>&1 | sed 's/^/  /'
              return 1
            }

            cleanup_old_container() {
              log_info "Cleaning up old container..."
              if container_exists "${OLD_CONTAINER_BACKUP}"; then
                log_info "Removing backed-up container: ${OLD_CONTAINER_BACKUP}"
                if docker rm -f "${OLD_CONTAINER_BACKUP}"; then
                  log_success "Old container removed"
                else
                  log_warn "Could not remove old container"
                fi
              fi
            }

            rollback_deployment() {
              log_warn "Starting rollback procedure..."
              if container_exists "$CONTAINER_NAME"; then
                log_info "Stopping new container..."
                docker stop "$CONTAINER_NAME" 2>/dev/null || true
                docker rm "$CONTAINER_NAME" 2>/dev/null || true
              fi
              if container_exists "${OLD_CONTAINER_BACKUP}"; then
                log_info "Restoring old container from backup: ${OLD_CONTAINER_BACKUP}"
                if docker rename "${OLD_CONTAINER_BACKUP}" "$CONTAINER_NAME" 2>/dev/null; then
                  if docker start "$CONTAINER_NAME"; then
                    log_success "Rollback successful: Old container restored"
                    return 0
                  else
                    log_error "Failed to start rolled-back container"
                    return 1
                  fi
                else
                  log_error "Failed to rename backed-up container"
                  return 1
                fi
              else
                log_error "No backed-up container available for rollback"
                return 1
              fi
            }

            show_container_status() {
              log_info "=== Container Status ==="
              docker ps -a --filter name="$CONTAINER_NAME" --filter name="${OLD_CONTAINER_BACKUP}" || log_info "No containers found"
              log_info "======================="
            }

            show_container_logs() {
              log_info "=== Container Logs (last 20 lines) ==="
              if container_exists "$CONTAINER_NAME"; then
                docker logs --tail 20 "$CONTAINER_NAME" || log_info "No logs available"
              fi
              log_info "======================================="
            }

            log_info "Starting deployment of ${APP_NAME}:${IMAGE_TAG}"
            log_info "Container name: ${CONTAINER_NAME}"
            log_info "Image: ${IMAGE}"
            log_info "Environment file: ${ENV_FILE}"
            log_info ""

            if [ ! -f "$ENV_FILE" ]; then
              log_error "Environment file not found: ${ENV_FILE}"
              exit 1
            fi
            log_success "Environment file found"

            backup_old_container || exit 1
            rename_old_container || exit 1
            pull_new_image || exit 1
            start_new_container || exit 1

            # TEMPORARILY DISABLED: Skip health check validation for now
            # TODO: Re-enable after verifying /actuator/health endpoint
            # if ! validate_container_health; then
            #   log_error "Health check failed, initiating rollback..."
            #   rollback_deployment || exit 1
            #   exit 1
            # fi

            cleanup_old_container

            log_success ""
            log_success "=== DEPLOYMENT SUCCESSFUL ==="
            show_container_status
            show_container_logs
            log_success "============================="

            rm -f "$ENV_FILE"
            DEPLOY_SCRIPT_EOF
              chmod +x "$DEPLOY_SCRIPT"
            fi

            # Create environment file
            cat > .env.espacogeek << 'ENVEOF'
            SPRING_DATASOURCE_URL=${{ secrets.SPRING_DATASOURCE_URL }}
            SPRING_DATASOURCE_USERNAME=${{ secrets.SPRING_DATASOURCE_USERNAME }}
            SPRING_DATASOURCE_PASSWORD=${{ secrets.SPRING_DATASOURCE_PASSWORD }}
            SPRING_MVC_CORS_ALLOWED_ORIGINS=${{ secrets.SPRING_MVC_CORS_ALLOWED_ORIGINS }}
            SECURITY_JWT_ISSUER=${{ secrets.SECURITY_JWT_ISSUER }}
            SECURITY_JWT_EXPIRATION_MS=${{ secrets.SECURITY_JWT_EXPIRATION_MS }}
            SECURITY_JWT_SECRET=${{ secrets.SECURITY_JWT_SECRET }}
            SAMESITE_WHEN_SAME_SITE=${{ secrets.SAMESITE_WHEN_SAME_SITE }}
            ALLOWED_ORIGINS=${{ secrets.ALLOWED_ORIGINS }}
            MAIL_HOST=${{ secrets.MAIL_HOST }}
            MAIL_PORT=${{ secrets.MAIL_PORT }}
            MAIL_USERNAME=${{ secrets.MAIL_USERNAME }}
            MAIL_PASSWORD=${{ secrets.MAIL_PASSWORD }}
            FRONTEND_URL=${{ secrets.FRONTEND_URL }}
            ENVEOF

            # Login to GHCR
            echo "${{ secrets.GHCR_TOKEN }}" | docker login ghcr.io -u "${{ secrets.GHCR_USER }}" --password-stdin

            # Execute deployment script
            "$DEPLOY_SCRIPT" "${GHCR_OWNER_LC}" "${APP_NAME}" "latest" ".env.espacogeek"


      # Final summary with generated tags
      - name: Summary
        if: always()
        run: |
          echo "Project version: ${{ steps.gradle_version.outputs.version }}"
          echo "Tags generated: ${{ steps.vars.outputs.tags_csv }}"
          echo "Push enabled: ${{ steps.vars.outputs.should_push }}"
